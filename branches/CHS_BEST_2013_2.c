#pragma config(Sensor, in2,    pot1,           sensorPotentiometer)
#pragma config(Sensor, in3,    pot2,           sensorPotentiometer)
#pragma config(Sensor, dgtl2,  lim1,           sensorTouch)
#pragma config(Sensor, dgtl3,  lim2,           sensorTouch)
#pragma config(Motor,  port2,           motor1,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           motor2,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           motor3,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           motor4,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           servo1,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           servo2,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           servo3,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           servo4,        tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void stepServo(tMotor motorPort, int t1) //move servo at given speed
{
	motor[motorPort] = motor[motorPort] + t1;
  wait1Msec(10);
}

void limMotor(tMotor mot1, tSensors sens1, int t2) //stop motor if limswitch pressed
{
	if(SensorValue[sens1] == 1)
		{
		motor[mot1] = t2;
		}
}

int getPotentiometer(tSensors pot)
{
	int t3 = SensorValue[pot];
	return t3;
}

void clawGoToPosition(tMotor first, tMotor second, tMotor third, tMotor fourth,
											int t4, int t5, int t6, int t7)
{
	motor[first] = t4;
	motor[second] = t5;
	motor[third] = t6;
	motor[fourth] = t7;
}

void moveAtAngle(tMotor motA,
								 tSensors potA,
								 int angle,
								 int speedA,
								 int pointErrorA,
								 int startPositionA,
								 float divideAngle1,
								 float divideAngle2)
{
	int z1 = startPositionA + angle*divideAngle1;
	int z2 = startPositionA + angle*divideAngle2;
	while(SensorValue[potA] > (startPositionA + angle) + pointErrorA ||  SensorValue[potA] < (startPositionA + angle) - pointErrorA)
		{
	  if(SensorValue[potA] < startPositionA + angle)
	  	{
			if(SensorValue[potA] < z1)
			{
				motor[motA] = speedA;
			}
			if(SensorValue[potA] < z1 + z2 - startPositionA &&
			 SensorValue[potA] > z1)
			{
				motor[motA] = speedA/2;
			}
			if(SensorValue[potA] > z1 + z2 - startPositionA)
			{
				motor[motA] = speedA/4;
			}
	  	}
	  if(SensorValue[potA] > startPositionA + angle)
	  	{
			if(SensorValue[potA] < angle + z2)
			{
				motor[motA] = -speedA/4;
			}
			if(SensorValue[potA] < angle + z1 &&
			   SensorValue[potA] > angle + z2)
			{
				motor[motA] = -speedA/2;
			}
			if(SensorValue[potA] > angle + z1)
			{
				motor[motA] = -speedA;
			}
	  	}
		}
	motor[motA] = 0;
}

void twoServos (tMotor servoPort1, tMotor servoPort2, int Btn) //control two servos with group 7 buttons
{
switch (Btn)
   {
   	case 4:
   	stepServo(servoPort1, 1);
   	break;

   	case 8:
   	stepServo(servoPort2, -1);
   	break;

   	case 16:
   	stepServo(servoPort1, -1);
   	break;

    case 32:
   	stepServo(servoPort2, 1);
   	break;

   	case 256:
   	clawGoToPosition(servo1,servo2, servo3, servo4, -127, -127, 0, 0);
   	break;

   	default:
   	wait1Msec(3);
   }
}

int BtnX = 0;

task main()
{
 int x = SensorValue[pot1];
 int y = SensorValue[pot2];

 while(true)
  {
   //assign values to buttons to change value of BtnX
   if (vexRT[Btn5U] == 1){
     BtnX = BtnX + 1;}

   if (vexRT[Btn5D] == 1){
     BtnX = BtnX + 2;}

   if (vexRT[Btn7U] == 1){
     BtnX = BtnX + 4;}

   if (vexRT[Btn7L] == 1){
     BtnX = BtnX + 8;}

   if (vexRT[Btn7D] == 1){
     BtnX = BtnX + 16;}

   if (vexRT[Btn7R] == 1){
     BtnX = BtnX + 32;}

   if (vexRT[Btn6U] == 1){
     BtnX = BtnX + 64;}

   if (vexRT[Btn6D] == 1){
     BtnX = BtnX + 128;}

   if (vexRT[Btn8U] == 1){
     BtnX = BtnX + 256;}

   if (vexRT[Btn8L] == 1){
     BtnX = BtnX + 512;}

   if (vexRT[Btn8D] == 1){
     BtnX = BtnX + 1024;}

   if (vexRT[Btn8R] == 1){
     BtnX = BtnX + 2048;}

   if ((vexRT[Btn7D] == 0)&&(vexRT[Btn7U] == 0)&&(vexRT[Btn7L] == 0)&&(vexRT[Btn7R] == 0)
     &&(vexRT[Btn8D] == 0)&&(vexRT[Btn8U] == 0)&&(vexRT[Btn8L] == 0)&&(vexRT[Btn8R] == 0)
     &&(vexRT[Btn5U] == 0)&&(vexRT[Btn5D] == 0)&&(vexRT[Btn6U] == 0)&&(vexRT[Btn6D] == 0)){
     BtnX = 0;}

   twoServos (servo1, servo2, BtnX);

   //joystick ch1 controls servo
    if((vexRT[Ch1] <= -40) && (vexRT[Ch1] > -80))
		{
			stepServo(servo1, -1);
		}
		else if((vexRT[Ch1] <= -80) && (vexRT[Ch1] > -110))
		{
			stepServo(servo1, -2);
		}
		else if(vexRT[Ch1] <= -110)
		{
			stepServo(servo1, -3);
		}

		if((vexRT[Ch1] >= 40) && (vexRT[Ch1] < 80))
		{
			stepServo(servo1, 1);
		}

		else if((vexRT[Ch1] >= 80) && (vexRT[Ch1] < 110))
		{
			stepServo(servo1, 2);
		}
		else if(vexRT[Ch1] >= 110)
		{
			stepServo(servo1, 3);
		}

		motor[motor1] = vexRT[Ch2];
		limMotor(motor1, lim1, 0);


	  moveAtAngle(motor2, pot1, 60, 80, 2, x, 0.5, 0.25);
	}
}
